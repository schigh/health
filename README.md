<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# health

```go
import "github.com/schigh/health"
```

## Index

- [Variables](<#variables>)
- [type AddCheckOption](<#AddCheckOption>)
  - [func WithCheckFrequency\(f CheckFrequency, interval, delay time.Duration\) AddCheckOption](<#WithCheckFrequency>)
  - [func WithCheckImpact\(liveness, readiness bool\) AddCheckOption](<#WithCheckImpact>)
- [type AddCheckOptions](<#AddCheckOptions>)
- [type CheckFrequency](<#CheckFrequency>)
- [type Checker](<#Checker>)
- [type CheckerFunc](<#CheckerFunc>)
  - [func \(cf CheckerFunc\) Check\(ctx context.Context\) \*healthpb.Check](<#CheckerFunc.Check>)
- [type CircuitBreaker](<#CircuitBreaker>)
- [type Config](<#Config>)
- [type Logger](<#Logger>)
- [type Manager](<#Manager>)
- [type NoOpLogger](<#NoOpLogger>)
  - [func \(n NoOpLogger\) Debug\(\_ string, \_ ...any\)](<#NoOpLogger.Debug>)
  - [func \(n NoOpLogger\) Error\(\_ string, \_ ...any\)](<#NoOpLogger.Error>)
  - [func \(n NoOpLogger\) Info\(\_ string, \_ ...any\)](<#NoOpLogger.Info>)
  - [func \(n NoOpLogger\) Warn\(\_ string, \_ ...any\)](<#NoOpLogger.Warn>)
- [type Reporter](<#Reporter>)
- [type Runner](<#Runner>)


## Variables

<a name="ErrAddCheckAlreadyRunning"></a>

```go
var ErrAddCheckAlreadyRunning = errors.New("health: cannot add a health check to a running health instance")
```

<a name="AddCheckOption"></a>
## type [AddCheckOption](<https://github.com/schigh/health/blob/main/checker.go#L28>)

AddCheckOption is a functional option for adding a Checker to a health managers.

```go
type AddCheckOption func(*AddCheckOptions)
```

<a name="WithCheckFrequency"></a>
### func [WithCheckFrequency](<https://github.com/schigh/health/blob/main/checker.go#L55>)

```go
func WithCheckFrequency(f CheckFrequency, interval, delay time.Duration) AddCheckOption
```

WithCheckFrequency tells the health instance the CheckFrequency at which it will perform check with the specified Checker instance. If the value for CheckFrequency is CheckOnce, the Interval parameter is ignored. If the value for CheckFrequency is CheckAtInterval, the value of Interval will be used. If the value of Interval is equal to or less than zero, then the default Interval is used. If the value of Delay is equal to or less than zero, it is ignored. This option is not additive, so multiple invocations of this option will result in the last invocation being used to configure the Checker.

<a name="WithCheckImpact"></a>
### func [WithCheckImpact](<https://github.com/schigh/health/blob/main/checker.go#L68>)

```go
func WithCheckImpact(liveness, readiness bool) AddCheckOption
```

WithCheckImpact tells the health instance that a healthcheck affects either the liveness or readiness of the application. Liveness and readiness are ways Kubernetes determines the fitness of a pod \(https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\). If liveness is affected by the failing health check, then readiness is also affected. By default, application liveness and readiness are not affected by health check.

<a name="AddCheckOptions"></a>
## type [AddCheckOptions](<https://github.com/schigh/health/blob/main/checker.go#L19-L25>)

AddCheckOptions contain the options needed to add a new health check to the manager.

```go
type AddCheckOptions struct {
    Frequency        CheckFrequency
    Delay            time.Duration
    Interval         time.Duration
    AffectsLiveness  bool
    AffectsReadiness bool
}
```

<a name="CheckFrequency"></a>
## type [CheckFrequency](<https://github.com/schigh/health/blob/main/checker.go#L31>)

CheckFrequency is a set of flags to instruct the.

```go
type CheckFrequency uint
```

<a name="CheckOnce"></a>

```go
const (
    // CheckOnce instructs the Checker to perform its check one time. If the
    // CheckAfter flag is set, CheckOnce will perform the check after a duration
    // specified by the desired configuration.
    CheckOnce CheckFrequency = 1 << iota

    // CheckAtInterval instructs the Checker to perform its check at a specified
    // Interval. If the CheckAfter flag is set, this check will begin after a
    // lapse of the combined Delay and Interval.
    CheckAtInterval

    // CheckAfter instructs the Checker to wait until after a specified time to
    // perform its check.
    CheckAfter
)
```

<a name="Checker"></a>
## type [Checker](<https://github.com/schigh/health/blob/main/health.go#L82-L85>)

Checker performs an individual health check and returns the result to the health manager.

```go
type Checker interface {
    // Check runs the health check and returns a check result
    Check(context.Context) *healthpb.Check
}
```

<a name="CheckerFunc"></a>
## type [CheckerFunc](<https://github.com/schigh/health/blob/main/checker.go#L11>)

CheckerFunc is a functional health checker.

```go
type CheckerFunc func(context.Context) *healthpb.Check
```

<a name="CheckerFunc.Check"></a>
### func \(CheckerFunc\) [Check](<https://github.com/schigh/health/blob/main/checker.go#L14>)

```go
func (cf CheckerFunc) Check(ctx context.Context) *healthpb.Check
```

Check satisfies Checker.

<a name="CircuitBreaker"></a>
## type [CircuitBreaker](<https://github.com/schigh/health/blob/main/cb.go#L19-L21>)

CircuitBreaker is a protective wrapper around any logic where an error tolerance can be exceeded, putting the circuit breaker into an open state. When a circuit breaker is open, the logic protected by the circuit breaker is not called. When a circuit breaker is backing off, the protected logic is called according to the backoff strategy of the circuit breaker. Circuit breakers do not directly affect the health of the application, but are an indicator of the application's ability to perform its tasks.

```go
type CircuitBreaker interface {
    Run(context.Context, Runner) (any, error)
}
```

<a name="Config"></a>
## type [Config](<https://github.com/schigh/health/blob/main/config.go#L3-L8>)



```go
type Config struct {
    HTTPPort               int    `envconfig:"HEALTH_HTTP_PORT" default:"8181"`
    LivenessEndpoint       string `envconfig:"HEALTH_LIVENESS_ENDPOINT" default:"/live"`
    ReadinessEndpoint      string `envconfig:"HEALTH_READINESS_ENDPOINT" default:"/ready"`
    CircuitBreakerEndpoint string `envconfig:"HEALTH_CB_ENDPOINT" default:"/cb"`
}
```

<a name="Logger"></a>
## type [Logger](<https://github.com/schigh/health/blob/main/logger.go#L3-L8>)



```go
type Logger interface {
    Debug(msg string, args ...any)
    Info(msg string, args ...any)
    Warn(msg string, args ...any)
    Error(msg string, args ...any)
}
```

<a name="Manager"></a>
## type [Manager](<https://github.com/schigh/health/blob/main/health.go#L13-L42>)

Manager defines a manager of health checks for the application. A Manager is a running daemon that oversees all the health checks added to it. When a Manager has new health check information, it dispatches an update to its Reporter\(s\).

```go
type Manager interface {
    // Run the health check manager. Invoking this will initialize all managed
    // checks and reporters. This function returns a read-only channel of errors.
    // If a non-nil error is propagated across this channel, that means the health
    // check manager has entered an unrecoverable state, and the application
    // should halt.
    Run(context.Context) <-chan error

    // Stop the manager and all included checks and reporters. Should be called
    // when an application is shutting down gracefully.
    Stop(context.Context) error

    // AddCheck will add a named health checker to the manager. By default, an
    // added check will run once immediately upon startup, and not affect
    // liveness or readiness. Options are available to set an initial check delay,
    // a check interval, and any affects on liveness or readiness. All added
    // health checks must be named uniquely.  Adding a check with the same name
    // as an existing health check (case-insensitive), will overwrite the previous
    // check. Attempting to add a check after the manager is running will return
    // an error.
    AddCheck(name string, c Checker, opts ...AddCheckOption) error

    // AddReporter adds a named health reporters to the manager. Every time a
    // health check is reported, the manager will relay the update to the
    // reporters. All added health reporters must be named uniquely.
    // Adding a reporters with the same name as an existing health reporters
    // (case-insensitive), will overwrite the previous reporters. Attempting to
    // add a reporters after the manager is running will return an error.
    AddReporter(name string, r Reporter) error
}
```

<a name="NoOpLogger"></a>
## type [NoOpLogger](<https://github.com/schigh/health/blob/main/logger.go#L10>)



```go
type NoOpLogger struct{}
```

<a name="NoOpLogger.Debug"></a>
### func \(NoOpLogger\) [Debug](<https://github.com/schigh/health/blob/main/logger.go#L12>)

```go
func (n NoOpLogger) Debug(_ string, _ ...any)
```



<a name="NoOpLogger.Error"></a>
### func \(NoOpLogger\) [Error](<https://github.com/schigh/health/blob/main/logger.go#L15>)

```go
func (n NoOpLogger) Error(_ string, _ ...any)
```



<a name="NoOpLogger.Info"></a>
### func \(NoOpLogger\) [Info](<https://github.com/schigh/health/blob/main/logger.go#L13>)

```go
func (n NoOpLogger) Info(_ string, _ ...any)
```



<a name="NoOpLogger.Warn"></a>
### func \(NoOpLogger\) [Warn](<https://github.com/schigh/health/blob/main/logger.go#L14>)

```go
func (n NoOpLogger) Warn(_ string, _ ...any)
```



<a name="Reporter"></a>
## type [Reporter](<https://github.com/schigh/health/blob/main/health.go#L55-L78>)

Reporter reports the health status of the application to a receiving output. The mechanism by which the Reporter sends this information is implementation\-dependent. Some reporters, such as an HTTP server, are pull\-based, while others, such as a stdout reporters, are push\-based. Each reporters variant is responsible for managing the health information passed to it from the health Manager. A Manager may have multiple reporters, and a Reporter may have multiple providers. The common dialog between reporters and providers is a map of HealthCheck items keyed by string. It is implied that all health checks within a system are named uniquely. A Reporter must be prepared to receive updates at any time and at any frequency. A Reporter curates the health checks passed to it.

```go
type Reporter interface {
    // Run the reporter
    Run(context.Context) error

    // Stop the reporters and release resources
    Stop(context.Context) error

    // SetLiveness instructs the reporters to relay the liveness of the
    // application to an external observer
    SetLiveness(context.Context, bool)

    // SetReadiness instructs the reporters to relay the readiness of the
    // application to an external observer
    SetReadiness(context.Context, bool)

    // UpdateHealthChecks is called from the manager to update the reported health checks. Only new health check invocations
    UpdateHealthChecks(context.Context, map[string]*healthpb.Check)

    // UpdateCircuitBreakers is called from the manager to update the reported
    // circuit breaker state. Only circuit breakers reporting a state change are
    // communicated via this function, so the reporters must manage that delta
    // internally.
    UpdateCircuitBreakers(context.Context, map[string]*healthpb.CircuitBreaker)
}
```

<a name="Runner"></a>
## type [Runner](<https://github.com/schigh/health/blob/main/cb.go#L10>)

Runner is any function that is dispatched by a circuit breaker. It is intended to wrap a protected area of logic such that it is not called while a circuit breaker is open.

```go
type Runner func(context.Context) (any, error)
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->