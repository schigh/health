// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package std

import (
	"sync"

	"github.com/schigh/health"
)

// reporterMap wraps map[string]health.Reporter, and locks reads and writes with a mutex
type reporterMap struct {
	mx        sync.RWMutex
	impl      map[string]health.Reporter
	onceToken sync.Once
}

// Get gets the health.Reporter keyed by string.
func (m *reporterMap) Get(key string) (value health.Reporter) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the reporterMap's internal map
func (m *reporterMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the reporterMap's internal map with the specified key
func (m *reporterMap) Set(key string, value health.Reporter) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.Reporter)
	})
	m.impl[key] = value
}

// Absorb will take all the keys and values from another reporterMap's internal map and
// overwrite any existing keys
func (m *reporterMap) Absorb(otherMap *reporterMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.Reporter)
	})
	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *reporterMap) AbsorbMap(regularMap map[string]health.Reporter) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.Reporter)
	})
	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a health.Reporter from the map by key
func (m *reporterMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.Reporter)
	})
	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *reporterMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]health.Reporter)
}

// Value returns a copy of the underlying map[string]health.Reporter
func (m *reporterMap) Value() map[string]health.Reporter {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]health.Reporter, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]health.Reporter
func (m *reporterMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

// Each runs a function over each key/value pair in the reporterMap
// If the function returns false, the interation through the underlying
// map will halt.
// This function does not mutate the underlying map, although the values
// of the map may be mutated in place
//
//	!!! Warning: calls to any mutating functions of reporterMap
//	!!! will deadlock if called from within the supplied function
func (m *reporterMap) Each(f func(key string, value health.Reporter) bool) {
	defer m.mx.Unlock()
	m.mx.Lock()

	for _k := range m.impl {
		_v := m.impl[_k]
		if !f(_k, _v) {
			return
		}
	}
}
