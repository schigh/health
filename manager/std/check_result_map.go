// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package std

import (
	"sync"
)

// checkResultMap wraps map[string]result, and locks reads and writes with a mutex
type checkResultMap struct {
	mx        sync.RWMutex
	impl      map[string]result
	onceToken sync.Once
}

// Get gets the result keyed by string.
func (m *checkResultMap) Get(key string) (value result) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the checkResultMap's internal map
func (m *checkResultMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the checkResultMap's internal map with the specified key
func (m *checkResultMap) Set(key string, value result) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]result)
	})
	m.impl[key] = value
}

// Absorb will take all the keys and values from another checkResultMap's internal map and
// overwrite any existing keys
func (m *checkResultMap) Absorb(otherMap *checkResultMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]result)
	})
	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *checkResultMap) AbsorbMap(regularMap map[string]result) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]result)
	})
	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a result from the map by key
func (m *checkResultMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]result)
	})
	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *checkResultMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]result)
}

// Value returns a copy of the underlying map[string]result
func (m *checkResultMap) Value() map[string]result {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]result, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]result
func (m *checkResultMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

// Each runs a function over each key/value pair in the checkResultMap
// If the function returns false, the interation through the underlying
// map will halt.
// This function does not mutate the underlying map, although the values
// of the map may be mutated in place
//
//	!!! Warning: calls to any mutating functions of checkResultMap
//	!!! will deadlock if called from within the supplied function
func (m *checkResultMap) Each(f func(key string, value result) bool) {
	defer m.mx.Unlock()
	m.mx.Lock()

	for _k := range m.impl {
		_v := m.impl[_k]
		if !f(_k, _v) {
			return
		}
	}
}
