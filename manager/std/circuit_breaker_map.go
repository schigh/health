// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package std

import (
	"sync"

	"github.com/schigh/health"
)

// circuitBreakerMap wraps map[string]health.CircuitBreaker, and locks reads and writes with a mutex
type circuitBreakerMap struct {
	mx        sync.RWMutex
	impl      map[string]health.CircuitBreaker
	onceToken sync.Once
}

// Get gets the health.CircuitBreaker keyed by string.
func (m *circuitBreakerMap) Get(key string) (value health.CircuitBreaker) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the circuitBreakerMap's internal map
func (m *circuitBreakerMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the circuitBreakerMap's internal map with the specified key
func (m *circuitBreakerMap) Set(key string, value health.CircuitBreaker) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.CircuitBreaker)
	})
	m.impl[key] = value
}

// Absorb will take all the keys and values from another circuitBreakerMap's internal map and
// overwrite any existing keys
func (m *circuitBreakerMap) Absorb(otherMap *circuitBreakerMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.CircuitBreaker)
	})
	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *circuitBreakerMap) AbsorbMap(regularMap map[string]health.CircuitBreaker) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.CircuitBreaker)
	})
	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a health.CircuitBreaker from the map by key
func (m *circuitBreakerMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]health.CircuitBreaker)
	})
	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *circuitBreakerMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]health.CircuitBreaker)
}

// Value returns a copy of the underlying map[string]health.CircuitBreaker
func (m *circuitBreakerMap) Value() map[string]health.CircuitBreaker {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]health.CircuitBreaker, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]health.CircuitBreaker
func (m *circuitBreakerMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

// Each runs a function over each key/value pair in the circuitBreakerMap
// If the function returns false, the interation through the underlying
// map will halt.
// This function does not mutate the underlying map, although the values
// of the map may be mutated in place
//
//	!!! Warning: calls to any mutating functions of circuitBreakerMap
//	!!! will deadlock if called from within the supplied function
func (m *circuitBreakerMap) Each(f func(key string, value health.CircuitBreaker) bool) {
	defer m.mx.Unlock()
	m.mx.Lock()

	for _k := range m.impl {
		_v := m.impl[_k]
		if !f(_k, _v) {
			return
		}
	}
}
