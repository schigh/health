// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package std

import (
	"sync"
)

// checkerMap wraps map[string]wrapper, and locks reads and writes with a mutex
type checkerMap struct {
	mx        sync.RWMutex
	impl      map[string]wrapper
	onceToken sync.Once
}

// Get gets the wrapper keyed by string.
func (m *checkerMap) Get(key string) (value wrapper) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the checkerMap's internal map
func (m *checkerMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the checkerMap's internal map with the specified key
func (m *checkerMap) Set(key string, value wrapper) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]wrapper)
	})
	m.impl[key] = value
}

// Absorb will take all the keys and values from another checkerMap's internal map and
// overwrite any existing keys
func (m *checkerMap) Absorb(otherMap *checkerMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]wrapper)
	})
	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *checkerMap) AbsorbMap(regularMap map[string]wrapper) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]wrapper)
	})
	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a wrapper from the map by key
func (m *checkerMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]wrapper)
	})
	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *checkerMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]wrapper)
}

// Value returns a copy of the underlying map[string]wrapper
func (m *checkerMap) Value() map[string]wrapper {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]wrapper, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]wrapper
func (m *checkerMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

// Each runs a function over each key/value pair in the checkerMap
// If the function returns false, the interation through the underlying
// map will halt.
// This function does not mutate the underlying map, although the values
// of the map may be mutated in place
//
//	!!! Warning: calls to any mutating functions of checkerMap
//	!!! will deadlock if called from within the supplied function
func (m *checkerMap) Each(f func(key string, value wrapper) bool) {
	defer m.mx.Unlock()
	m.mx.Lock()

	for _k := range m.impl {
		_v := m.impl[_k]
		if !f(_k, _v) {
			return
		}
	}
}
